#!/bin/sh
# Fixed download quotas per ip, cap download once over quota

die()   {  echo "$@"; exit 1;  }
config=`dirname $0`/quotas.config
[ -f "$config" ] || die "quotas.config missing"
source "$config"

check_interface()  {  ifconfig "$1" >/dev/null 2>&1 ;  }
check_interface "$if_lan" || die "$config: interface $if_lan doesn't exist !"
check_interface "$if_wan" || die "$config: interface $if_wan doesn't exist !"
lan_current=`ifconfig $if_lan | grep 'inet addr' | sed -e 's/.*:\([^ ]*\) .*/\1/' | cut -d. -f1-3 `
[ "$lan" = "$lan_current" ] || die "$config: lan=$lan  should be $lan_current"

echo "--------------------------------------------------------------------------------"
echo "setting up download quotas: $dl_quota_mb Mb"
echo "limiting downloads to $dl_cap_max_kb k/s (overquota: $dl_cap_kb k/s)"
echo "for lan interface: $if_lan   range: [ $lan.$ip_start - $lan.$ip_end ]"
echo "--------------------------------------------------------------------------------"
echo ""

indexes() { seq $ip_start $ip_end; }
run() { echo "$@"; "$@"; r=$?; if [ $r != 0 ]; then echo "failed !"; fi; return $r;  }
bit_set() {  [ $(( $1 & (1<<$2) )) != 0 ];  }


#######################################################################
# reset tc / iptables
echo "resetting tc iptables and ipset"
`dirname $0`/disable_quotas

#######################################################################
# tc: create classes for each ip

insmod sch_htb
insmod sch_sfq
insmod cls_fw

TCA="tc class add dev $if_lan"
TFA="tc filter add dev $if_lan"
TQA="tc qdisc add dev $if_lan"
SFQ="sfq perturb 10"

run $TQA root handle 1: htb
for i in `indexes`; do
    echo "creating tc classes for $lan.$i"
    id=$i
    # over quota speed limits
    $TCA parent 1: classid 1:$id htb rate ${dl_cap}kbit ceil ${dl_cap}kbit prio 2
    $TQA parent 1:$id handle $id: $SFQ
    $TFA parent 1:0 prio 2 protocol ip handle $id fw flowid 1:$id

    id=$(($i + 512))
    # normal speed limits
    $TCA parent 1: classid 1:$id htb rate ${dl_cap_max}kbit ceil ${dl_cap_max}kbit prio 2
    $TQA parent 1:$id handle $id: $SFQ
    $TFA parent 1:0 prio 2 protocol ip handle $id fw flowid 1:$id
done

#######################################################################
# create ipsets

insmod nfnetlink
insmod ip_set
insmod ip_set_bitmap_ip

# ipset for accounting, no timeout
run ipset create IP_QUOTA bitmap:ip range $lan.0/24 counters
run ipset add IP_QUOTA $lan.$ip_start-$lan.$ip_end

# lan ips bit sets
for b in `seq 0 7`; do
    echo "creating ipset IPS_BIT$b" 1>&2
    echo "create IPS_BIT$b bitmap:ip range $lan.0/24"
    for i in `indexes`; do
	if bit_set $i $b; then
	    echo "add IPS_BIT$b $lan.$i"
	fi
    done
done | run ipset restore

#######################################################################
# iptables: check quotas and mark packets

insmod xt_set

# check quotas and set unique mark per ip (last digit).
# ip bit sets allow to drastically reduce number of rules needed:
# 8 rules instead of 256 to set a unique mark with naive (but simpler):
#   for i in `indexes`; do
#     iptables -j MARK --set-mark $i
#   done

IPT="iptables -t mangle"
IPT_POST="iptables -t mangle -A POSTROUTING -o $if_lan"

run $IPT -N normal
run $IPT -N overquota
run $IPT_POST -j MARK --set-mark 0    # just be safe
run $IPT_POST -m set --match-set IP_QUOTA dst --bytes-lt $dl_quota -j normal
run $IPT_POST -m set --match-set IP_QUOTA dst --bytes-gt $dl_quota -j overquota

# set mark for regular download limit
for b in `seq 0 7`; do		# set mark from ip lower bits
    run $IPT -A normal -m set --match-set IPS_BIT$b dst -j MARK --or-mark $((1<<$b))
done
run $IPT -A normal -j MARK --or-mark 512

# if over quota, set mark for hard speed limit
for b in `seq 0 7`; do		# set mark from ip lower bits
    run $IPT -A overquota -m set --match-set IPS_BIT$b dst -j MARK --or-mark $((1<<$b))
done

