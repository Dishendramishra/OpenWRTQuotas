#!/bin/sh
# Keep track of download usage by mac adress:
# Watch arp table and save/restore ip counters when it changes
# Run this every minute in cron

# don't do anything if quota isn't setup
ipset list IP_QUOTA > /dev/null || exit 0

# lan interface
if=br-lan

####################################################################################
# mac host names table
mac_names=/tmp/mac_names
name_for_mac() {  cat $mac_names | grep -F $1 | head -1 | cut -d' ' -f2 ;  }
host_name() {  nslookup "$1" | tail -1 | cut -d' ' -f4- ;  }

####################################################################################
# total downloads by mac address
mac_counters=/tmp/mac_counters

get_mac_counter() {  ( grep -F $1 < $mac_counters || echo $1 0 ) | cut -d' ' -f2 ;  }

set_mac_counter()
{ 
    mac=$1;  count=$2
    tmp=/tmp/mac_counters_
    timestamp=`date +"%s"`
    name=`name_for_mac $mac`
    grep -vF $mac < $mac_counters > $tmp
    echo $mac $count $timestamp "$name" >> $tmp
    mv $tmp $mac_counters
}

####################################################################################
# get/set ip counters

get_ip_counter()
{
    ( ipset save IP_QUOTA | grep -F "$1 " || 
      echo "add IP_QUOTA $1 packets 0 bytes 0" ) | cut -d' ' -f 7
}

set_ip_counter() {  ipset add -exist IP_QUOTA $1 bytes $2 ;  }

####################################################################################
# current / previous arp tables
cur=/tmp/arp
prev=/tmp/arp.prev

# just keep ip and mac
parse_arp() {  grep $if | grep -v 00:00:00:00:00:00 | sed -e 's/  */ /g' | cut -d' ' -f1,4 ;  }
list_arp()  {  tr ' ' '\n' ;  }
arp_has()   {  grep -qF "$1 $2" ;  }
mac_ips()   {  grep -F $1 | cut -d' ' -f1 ;  }
list_macs() {  cut -d' ' -f2 | sort -u ;  }
dup_macs()  {  [ -f $1 ] && [ `wc -l < $1` != `list_macs < $1 | wc -l` ];  }

####################################################################################

parse_arp < /proc/net/arp > $cur

# save usage of mac addresses which disappeared
list_arp < $prev | while read ip ; read mac; do
    if ! arp_has $ip $mac < $cur; then
	count=`get_ip_counter $ip`
	echo "saving $ip $mac: $count"
	set_mac_counter $mac $count
	set_ip_counter $ip 0
    fi
done

# restore new mac addresses ip counter
list_arp < $cur | while read ip ; read mac; do
    if ! arp_has $ip $mac < $prev; then
	mac_count=`get_mac_counter $mac`  # saved mac usage
	ip_count=`get_ip_counter $ip`     # bytes transferred since we last run
	count=$(( $mac_count + $ip_count ))	
	echo "new $ip $mac: setting count $count"
	set_ip_counter $ip $count
    fi
done

# messy case: multiple arp entries for a mac.
# if mac changes ip somehow, replicate ip counters
if dup_macs $cur; then 
    for mac in `list_macs < $cur`; do
	[ `mac_ips $mac < $cur | wc -l` = 1 ] && continue
	
	max_count=0
	ips=`mac_ips $mac < $cur`
	for ip in $ips; do
	    count=`get_ip_counter $ip`
	    [ $count -gt $max_count ] && max_count=$count
	done
	
	for ip in $ips; do
	    echo "dup $ip $mac: setting count $max_count"
	    set_ip_counter $ip $max_count
	done
    done
fi

# save computer names for logging
rm $mac_names
list_arp < $cur | while read ip ; read mac; do
    name=`host_name $ip`
    [ -n "$name" ] || name=`name_for_mac $mac`
    [ -n "$name" ] && echo "$mac $name" >> $mac_names
done


mv $cur $prev
