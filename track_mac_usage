#!/bin/sh
# Keep track of download usage by mac adress:
# Watch arp table and save/restore ip counters when it changes
# Run this every minute in cron

die()   {  echo "$@"; exit 1;  }
config=`dirname $0`/quotas.config
[ -f "$config" ] || die "quotas.config missing"
source "$config"


# don't do anything if quota isn't setup
ipset list IP_QUOTA > /dev/null || exit 0

####################################################################################
# mac to hostname table

mac_names=/tmp/mac_names
name_for_mac() {  cat $mac_names | grep -F $1 | head -1 | cut -d' ' -f2 ;  }

# hostname for ip address, no spaces please
host_name() { 
    name=`nslookup "$1" | tail -1 | cut -d' ' -f4- | tr ' '  '_' `
    [ -z "$name" ] && name=`grep -F "$1 " < /tmp/dhcp.leases | cut -d' ' -f4`
    echo "$name"
}

####################################################################################
# total downloads by mac address (offline devices)
# format: mac bytes timestamp hostname
mac_counters=/tmp/offline_mac_counters

get_mac_counter() {  ( grep -F $1 < $mac_counters || echo $1 0 ) | cut -d' ' -f2 ;  }

set_mac_counter()
{ 
    mac=$1;  count=$2
    tmp=/tmp/mac_counters_
    timestamp=`date +"%s"`
    name=`name_for_mac $mac`
    grep -vF $mac < $mac_counters > $tmp
    echo $mac $count $timestamp "$name" >> $tmp
    mv $tmp $mac_counters
}

####################################################################################
# get/set ip counters

get_ip_counter()
{
    ( ipset save IP_QUOTA | grep -F "$1 " || 
      echo "add IP_QUOTA $1 packets 0 bytes 0" ) | cut -d' ' -f 7
}

set_ip_counter() {  ipset add -exist IP_QUOTA $1 bytes $2 ;  }

####################################################################################
# current / previous arp tables
cur=/tmp/arp
prev=/tmp/arp.prev

# just keep ip and mac
parse_arp() {  grep $if_lan < /proc/net/arp | grep -vF 00:00:00:00:00:00 | sed -e 's/  */ /g' | cut -d' ' -f1,4 ;  }
list_arp()  {  tr ' ' '\n' ;  }
arp_has()   {  grep -qF "$1 $2" ;  }
mac_ips()   {  grep -F $1 | cut -d' ' -f1 ;  }
list_macs() {  cut -d' ' -f2 | sort -u ;  }
dup_macs()  {  [ -f $1 ] && [ `wc -l < $1` != `list_macs < $1 | wc -l` ];  }

####################################################################################

parse_arp > $cur

# save usage of mac addresses which disappeared
list_arp < $prev | while read ip ; read mac; do
    if ! arp_has $ip $mac < $cur; then
	count=`get_ip_counter $ip`
	echo "saving $ip $mac: $count"
	set_mac_counter $mac $count
	set_ip_counter $ip 0
    fi
done

# restore new mac addresses ip counter
list_arp < $cur | while read ip ; read mac; do
    if ! arp_has $ip $mac < $prev; then
	mac_count=`get_mac_counter $mac`  # saved mac usage
	ip_count=`get_ip_counter $ip`     # bytes transferred since we last run
	count=$(( $mac_count + $ip_count ))	
	echo "new $ip $mac: setting count $count"
	set_ip_counter $ip $count
    fi
done

# messy case: multiple arp entries for a mac.
# if mac changes ip somehow, replicate ip counters
if dup_macs $cur; then 
    for mac in `list_macs < $cur`; do
	[ `mac_ips $mac < $cur | wc -l` = 1 ] && continue
	
	max_count=0
	ips=`mac_ips $mac < $cur`
	for ip in $ips; do
	    count=`get_ip_counter $ip`
	    [ $count -gt $max_count ] && max_count=$count
	done
	
	for ip in $ips; do
	    echo "dup $ip $mac: setting count $max_count"
	    set_ip_counter $ip $max_count
	done
    done
fi

####################################################################################
# save computer names for logging

current_names()
{
    list_arp < $cur | while read ip ; read mac; do
	name=`host_name $ip`
	[ -n "$name" ] && echo "$mac $name"
    done
}

saved_names() {  cat $mac_names 2>/dev/null;  }

# merge current and saved names (keep latest)
AWK_MERGE_NAMES='{ name[$1]=$2; } END{ for (mac in name){ print mac " " name[mac]; } }'
(  saved_names;  current_names  )  | awk "$AWK_MERGE_NAMES" > /tmp/mac_names_
mv /tmp/mac_names_ $mac_names

####################################################################################
# done !

mv $cur $prev
